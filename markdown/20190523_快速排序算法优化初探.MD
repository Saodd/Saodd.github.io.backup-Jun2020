# 快速排序算法优化初探

> 今天自己实现一下`快速排序`算法，发现它几乎是线性的时间复杂度，
对比`选择排序`的平方级时间复杂度，算是切身体会了一下**算法**的威力。

## 辅助代码

```golang
// 定义一个类
type sort_Quick struct {
}

// 检查数组是否有序
func (self sort_Quick) sort(li []int) {
	self._sort(li, 0, len(li)-1)
}

// 递归排序
func (self sort_Quick) _sort(li []int, lo, hi int) {
	if lo >= hi {
		return
	}
	mid := self.partition(li, lo, hi)
	self._sort(li, lo, mid-1)
	self._sort(li, mid+1, hi)
}

// 对比运行 ---------------------------------------------------------------
func Main0003() {
	data := mytools.Gen_ints_list(40000000)
	data2 := make([]int, len(data))
	starttime := time.Now()
	t := time.Microsecond
	// ---------------------------
	for i := range data{
		data2[i] = data[i]
	}
	fmt.Println("Checking input for Quick-sort:", is_Sorted(data2))
	starttime = time.Now()
	sort_Quick{}.sort(data2)
	t = time.Since(starttime)
	fmt.Printf("Quick-sort: %v,   used time: %v seconds.\n", is_Sorted(data2), t)
	// ---------------------------
	for i := range data{
		data2[i] = data[i]
	}
	fmt.Println("Checking input for Quick-sort-Book:", is_Sorted(data2))
	starttime = time.Now()
	sort_Quick_Book{}.sort(data2)
	t = time.Since(starttime)
	fmt.Printf("Quick-sort-Book: %v,   used time: %v seconds.\n", is_Sorted(data2), t)
```
道理很简单，但是核心是`partition(li, lo, hi)`这个函数。



## 我的实现

没有看书，自己琢磨了将近2个小时。
一开始我是很担心在递归中申请额外的变量会带来时间和空间的负担，
所以没有使用辅助变量。

```golang
func (self sort_Quick) partition(li []int, lo, hi int) int { 
	// mid和hi去循环
	mid := lo
	for mid<hi{
		for mid<hi{ // 寻找左边更大的元素
			if li[mid]>li[lo]{
				break
			}
			mid++
		}
		for mid<hi{ // 寻找右边更小的元素
			if li[hi]<li[lo]{
				break
			}
			hi--
		}
		if mid < hi{ // 没有相遇就交换二者
			li[mid], li[hi] = li[hi], li[mid]
		}else if li[mid]<li[lo]{ // 相遇了那就再检查一下相遇的位置，找到更小的
			li[mid], li[lo] = li[lo], li[mid]
			lo = mid
		}else { // 相遇了那就再检查一下相遇的位置，找到更小的
			li[mid-1], li[lo] = li[lo], li[mid-1]
			lo = mid -1
		}
	}
	return lo
}
```

## 书上的实现

我的算法书是红色那本*Robert Sedgewick*的《算法（第四版）》，
其实书上是用java实现的，我用golang表达一下。
最大的区别就是golang不支持i++在表达式内的使用。

```golang
func (self sort_Quick_Book) partition(li []int, lo, hi int) (mid int) {
	i,j := lo, hi+1 // 从结果看来，在递归函数中定义变量，并不会带来额外的内存开销
	v:= li[lo]
	for {
		for i++; li[i]<v;i++ {
			if i==hi{
				break
			}
		}
		for j--; v < li[j]; j--{
			if j==lo{
				break
			}
		}
		if i>=j {
			break
		}
		li[i] , li[j] = li[j] , li[i]
	}
	li[lo] , li[j] = li[j] , li[lo]
	return j
}
```

## 运行结果：

在2000万个int的条件下，我的实现vs书上的实现：

 - 1.94s/1.81s = 107%
 - 1.94s/1.81s = 107%
 - 1.95s/1.81s = 108%

我的更慢8% ……  


## 尝试改进

首先可以看到是我在内部循环中，对数组的访问多了一些，像这样的：
```golang
if li[mid]>li[lo]{
```
所以我设置一个辅助变量，并替换两个循环中的条件：
```golang
midv := li[lo]
...
li[mid]>midv
```
这种情况下再尝试一下：

 - 1.906/1.810 = 105.3%
 - 1.885/1.824 = 103.3%
 - 1.892/1.825 = 103.6%
 
在3%-4%的性能差距我觉得应该可以接受了吧，
多出来的部分应该是在边界检查的时候多少一两次操作导致的。
感觉也没有细节优化的余地了，除非把逻辑重写一遍。

## 小结

下一步试一试将插入排序融合进入快速排序中，看看对性能有多少提升。
