---
layout: post
title:  "网络学习笔记4：网络层"
date:   2019-11-04
tags: 网络
color: rgb(255,102,51)
---

> 第三层，网络层。主要是IP协议。

# 第四章 Network Layer

网络层在每个终端和路由器中都在运行着，因此它是最复杂也是最有趣的一层。

在这一章里，我们首先要区分『转发`forwarding`』和『路由`routing`』：转发是在单个路由器中从输入端移到输出端的过程，而路由指的是所有路由器工作的集合。在现实中『转发』和『路由』经常被混淆使用，在本章中会精确地区分。
 
为了深入理解转发，我们会看看路由器的内部构造。然后学习IP、NAT、IPv4、ICMP、IPv6等概念。为了理解路由，我们会学习路由算法。

## 4.1 介绍

### 4.1.1 转发和路由

每个路由器都有『转发表`forwarding table`』。从输入包中读取头部某个字段，然后在表中查找知道从哪个口输出。表大概长这样：

|  header value  |  output link  |
| :---: | :---:|
| 0100 | 3 |
| 0101 | 2 |
| 0111 | 2 |
| 1001 | 1 |

还有一些术语要说明一下。我们接下来说『包交换`packet switch`』指的是一种通用的、根据包头字段从输入端转发到输出端的交换设备。有连接层交换机和路由器这两种。

除了转发和路由之外，网络层还有一个重要功能是『连接准备`connection setup`』，就像TCP的三次握手一样，有些网络层架构要求提前准备好连接状态。

### 4.1.2 网络服务模型

提供的服务其实跟TCP当时分析的差不多，就是那些。因特网架构提供的服务模型是『尽力Best Effort』，不保证带宽、丢包、顺序、延迟、拥塞控制。还有一种架构称为`ATM`，可能提供可靠传输服务。

## 4.2 虚拟电路和数据报网络

网络层与传输层类似的，也分为面向连接的和无连接的服务两种。看起来是重复了，但是我们注意一些关键不同：

- 网络层提供的是主机到主机的服务，而传输层是进程到进程的；
- 有连接的称为『虚拟电路网络`virtual-circuit(VC) network`』，无连接的称为『报文段网络`datagram networks`』。
- 面向连接服务的实现完全不同。传输层是在终端上进行控制，而网络层是在网络核心（路由器）上实现的。

### 4.2.1 虚拟电路网络

一个VC包含：①一条从始发地到目的地的『路径`path`』，由沿途的link和routers组成；②『VC号码』，沿着路径上每个link都有一个号码；③存在路径上的路由器中的转发表中的记录。

每个数据包都会在header中包含一个VC号码，而由于每个link可能是不同的号码，因此每次转发时都要更换header中的VC号码。

转发表大概长这样：

|  Incoming Interface  |  Incoming VC #  |  Outgoing Interface  |  Outgoing VC #  |
| :---: | :---:| :---: | :---:|
| 1 | 12 | 2 | 22 |
| 2 | 63 | 1 | 18 |
| 3 | 97 | 2 | 17 |
| 1 | 7 | 3 | 87 |

为什么每次转发都要更换号码？第一减少头部的号码字段长度，第二每个路由器可以随意独立地选择号码而无需跟其他路由器确认。

VC的生命周期有三个阶段：

- VC设置：终端网络层负责决定路径，在这个过程中会在路径上每个路由器设置VC号码。
- 数据传输
- VC关闭：反向操作，即通知路径上的路由释放掉相关的号码。

记住，传输层只是在两个终端上建立连接变量；而网络层是在整个沿途的所有路由上建立。

### 4.2.2 报文段网络

在报文段网络中，每个数据包上都会写入目标地址。每个路由器都会检查目标地址，然后发往对应的link；路由器维护的转发表中，键就是目标地址。

想象一下转发表长什么样子。我们知道IP地址是32位，意味着有40亿条记录，因此路由器不可能为每个IP都单独设置规则。

更加现实一点，路由器可以根据地址的范围来决定转发规则。或者，根据地址的前缀（前n位）来决定。其中有个小细节注意一下，某个地址有可能匹配了多个前缀，此时按照『最长前缀匹配原则』来决定。

虽然报文段网络中的路由器无需维护连接，但是必须要维护转发表。但由于转发表的更新频率相对来说很低，大概1-5分钟更新一次。

由于报文段网络中的路由器的转发表随时可能更新，因此某个终端发往另一个终端的一系列数据包可能会经过完全不同的路径，因此会造成乱序等问题，这也是上层TCP解决的问题之一。

### 4.2.3 起源

虚拟电路网络的思想是源自于电话系统的，电话系统是建立在真实电路网络上，因此虚拟电路更加复杂。

而报文段网络的代表，因特网，设计目标是将所有的电脑连接在一起。考虑到终端越来越强大，网络层被设计得尽可能简单。即网络层不提供任何保证，所以自然地要求也被降到了最低，所以很容易与不同的连接层协议进行兼容。

## 4.3 路由器的内部结构

- 输入端口：首先负责从物理层处理，然后是连接层处理，最后在转发表中进行查询并决定数据包发往哪个输出端口。注意这里的端口是指物理意义上的端口，而不是软件上的。
- 交换矩阵（`Switching fabric`）：连接输入端口和输出端口。
- 输出端口：从交换矩阵中获得数据包，并将其转化为连接层、物理层数据包然后发出去。要注意的是如果连接是双工的，那么输入端和输出端在电路上是放在一起的。
- 路由处理器：处理『路由协议`router protocols`』，维护路由表、转发表，还负责路由管理功能。

输入端、交换矩阵、输出端共同组成『路由转发板`router forwarding plane`』，几乎所有的转发功能都通过硬件来实现，因为在巨大流量压力下，每个报文段的处理时间可能只有几纳秒，只有硬件才能实现这种速度。相对的，路由处理器放在『路由控制板』上，运行在毫秒级的性能尺度上。

### 4.3.1 输入处理

路由处理器计算出转发表之后，会将其分别复制到每个输入端的本地内存中，以优化性能。内存也很有讲究，（注意所有实现要通过硬件而不是软件）必须要求查询的时间复杂度是常数级，因此内存是基于高速缓存设计的，只要根据IP去查询就能得到输出端口号（实质上已经可以理解为是一个翻译器而不是内存了）。

当数据包的输出端口被决定以后，就可以发往交换矩阵了。在有些设计中，如果线路被占用了那就可能会稍微阻塞一会儿。

### 4.3.2 交换

交换矩阵是路由器的核心部分，有几种实现：

#### 通过内存交换

早期的也是最简单的模式。处理器将输入输入端口视作传统的IO设备。数据包到来时，通过『中断』来通知处理器，处理器将其拷贝到内存中，然后查询转发表，然后拷贝到输出端。

现代的路由器大多是通过内存。不过，查询和拷贝的操作是由每个输入端线上芯片独立处理的，看起来非常像是共享内存的多处理器。

#### 通过总线交换

这种模式下，输入端通过一个共享的总线，直接将数据包传到输出端，不经过处理器。输入端会给数据包打上标签，所有的输出端都会收到数据包，但是只有标签指向的那个输出端才会处理这个包。

总的网速受限于总线的速度，不过在小型局域网中还是不错的。

#### 通过交互连接（Crossbar）

![2019-11-05-Crossbar.png](/static/blog/2019-11-05-Crossbar.png)

每个输入端和每个输出端都有自己的总线，总线之间互相连接，交点是开关。『交换矩阵处理器』负责控制交点的开闭。这样允许不同的线路上进行并行传输。

### 4.3.3 输出处理

### 4.3.4 队列

输出端也有缓冲区，当传入输出端的速度太快，缓冲区会被填满，然后发生丢包。（输入端和输出端同样原理）多大的缓冲区合适？理论推荐值是平均来回时间与连接速度的乘积，比如`10Mbps*250ms=2.5Mb`。

既然有排队，那就有调度算法。最简单的是『先到先得FCFS』，高级一点的有『权重公平队列WFQ』。

丢包也有算法。可以选择拒绝接受新来的包、或者丢掉队列中的包腾出空间，在某些情况下，在缓冲区未满的时候就丢包可以起到给发送端提醒拥塞控制的作用。最流行的算法是『随机早期检测`Random Early Detection`』，即设置一个下限和上限，当平均队列长度小于下限时，完全接受；当平均队列长度高于上限时，完全丢弃；介于中间时，计算概率随机丢弃。

特别注意的是，前面讨论的是『输出端的传入队列』，但是在『输入端的传出队列』同样会阻塞，会严重影响网络的效率，这个现象称为HOL。

### 4.3.5 路由控制板

我们已经了解到路由器中是有多个模块的，模块之间独立工作，通过互相发送控制消息来交互。

## 4.4 IP协议：转发与定位

前面讲的都是一些理论模型，现在讲点实际的，IP协议。它目前有两个版本，IPv4和IPv6。

其实，网络层不仅仅包含IP协议。还包括路由协议和控制消息协议。

![2019-11-05-network-layer-inside.png](/static/blog/2019-11-05-network-layer-inside.png)

### 4.4.1 报文段格式

网络层数据包称为『报文段`datagram`』，我们先看看IPv4的结构：

![2019-11-05-ipv4-format.png](/static/blog/2019-11-05-ipv4-format.png)

几个重要字段解释一下：

- `Version number`。表明了IP协议的版本号，这决定了剩下的数据应该如何读取。上图展示的是IPv4的格式。
- `Header length`。因为IP协议头部长度可变（即包含了可选字段），因此需要这个字段来说明从哪里开始是Body。大多数报文段都不包含可选，因此典型长度就是20bytes。
- `Type of service`（TOS）。用于表明这个报文段对于网络的需求（比如要求低延迟、或高通量、或可靠性）。我们在第七章研究。
- `Datagram length`。整个报文段的长度。字段长度16bit即最大支持65535bytes的报文段长度，不过很少超过1500bytes。
- `Identifier`, `flags`, `fragmentation offset`。这些字段用于支持『分裂`IP fragmentation`』，有趣的是IPv6不支持。
- `Time-to-live`。用来防止报文段在网络中无限循环。每次转发时减一，归零时被强制丢弃。
- `Protocol`。当报文段到达目的终端时使用，用来决定这个报文段发往上层的哪个协议，很类似传输层协议中的端口号。比如6表示TCP而17表示UDP。
- `Header checksum`与TCP的校验是一样的，如果有错误就丢弃报文段。但是要注意的是每次转发都要重新计算，因为TTL字段改变了。为什么两个层都要校验和？第一，IP层的校验范围是IP层报文段；第二，IP和TCP/UDP并不一定要同时使用，可以选择其他协议。
- `Source and destination IP addresses`
- `Options`。支持IP报文段头部的拓展功能，不过很少使用，而且这会给路由器带来性能负担。在IPv6中舍弃了。
- `Data (payload)`。包含TCP、UDP或者ICMP数据包。

值得提醒的是，IP头是20bytes，TCP头也是20bytes。

#### IP报文段分裂

由于下面的连接层千差万别，每种协议的『最大传输单元（MTU）』都是不同的，因此一个IP报文段可能会被拆分，形成『碎片`fragment`』。

由于碎片的重组会给IP协议增加复杂度，并且影响路由器的性能，IPv4的设计者将这个任务交给终端来做。

路由器还是要负责拆解碎片（因为发送端不知道路途中最小的MTU是多少）。每个碎片都会打上相同的来源地址、目标地址、标识码。

报文段的分裂和重组，会增加设计复杂度和性能负担；同时还增加了系统的弱点（有针对这里的DoS攻击方式）。Ipv6有了很大的改进。

### 4.4.2 IPv4定位

先讲个细节。每台终端/路由器与物理线路之间的界面，称为『接口`interface`』，终端一般有一个而路由器一般有多个。由于每个接口是具备收发能力的，因此在技术上看IP地址是与接口关联起来的，而不是终端/路由器。

IP地址长度32bits（或者4bytes），一般我们用『点分十进制记法`dotted-decimal notation`』来表示，比如`193.32.216.9`表示`11000001 00100000 11011000 00001001`。

IP地址不是随意决定的，而是要根据所在的『子网`subnet`』来决定。

![2019-11-05-Interface-addresses-and-subnets.png](/static/blog/2019-11-05-Interface-addresses-and-subnets.png)

在下图红色方框里的三个接口组成一个子网，子网中没有路由器，中间的可能是一个『以太网`Ethernet`』或者『无线网`Wireless`』。这个子网有它自己的IP地址，例如左边的子网是`223.1.1.0/24`，其中`/24`是『子网掩码`subnet mask`』表示前24位定义这个子网的地址。子网中所有的IP地址必须以子网地址开头，例如`223.1.1.1`。

因特网的地址分配策略是『无类域间路由`Classless Interdomain Routing`（CIDR）』，用`/24`这样的形式将IP地址分为两个部分。前面的部分称为『前缀`prefix`』，每个组织（或ISP）获得一段IP地址后，因特网中所有匹配该前缀的报文段都会发往这个组织的路由器中。

在CIDR之前，IP地址是按小数点划分的，即8位、16位和24位。8位太小而16位太大，因此发展出CIDR能更加灵活。

有一个特殊的IP地址要提一下，即『广播地址』`255.255.255.255`，如果向这个地址发送报文段，同一个子网下的所有终端都会收到。

#### 获取一段地址集

就是向上级ISP请求分配。上级ISP必须有一个更大的地址集，例如`200.23.16.0/20`然后可以分配出`200.23.16.0/23`。

在最顶端，由『Internet Corporation for Assigned Names and Numbers (ICANN)』负责分配顶级IP。同时它也管理着顶级DNS根服务器，以及顶级域名的分配。

#### 获取一个IP地址

IP地址一般是手动注册到路由器中的，终端地址也可以手动，不过一般通过『Dynamic Host Configuration Protocol (DHCP)』来自动获取。我们称其为『即插即用式`plug-and-play protocol`』，它也是Client/Server模型的。

当一个新的客户端加入时，DHCP有四个步骤：

- DHCP服务器发现。客户端先发送一个UDP数据包，称为『`DHCP discover message`』，发往`255.255.255.255:67`广播地址并将源地址标为`0.0.0.0`。
- DHCP服务器提供。收到搜索消息后，服务器发回一个『`DHCP offer message`』，也通过`255.255.255.255:68`广播出去。为什么是广播呢？因为子网中可能有多个DHCP，客户端可以选择一个offer。每个offer包含会话ID、IP地址和有效时间，有效时间一般是几个小时或者几天。
- DHCP请求。客户端选择一个（或多个），发送`DHCP request message`
- DHCP确认。

#### 网络地址翻译 NAT

（译者简述）公网IP是很宝贵的，因此可以以路由器为单位共享一个IP。通过『网络地址翻译`network address translation` (NAT) 』机制，将局域网IP+port与公网IP+port进行转换，达到共享公网IP的目的。储存这个对应关系的数据结构称为『`NAT translation table`』。要注意的是，端口最多是65536个，最多只支持这么多个连接共用一个IP。

![2019-11-05-NAT.png](/static/blog/2019-11-05-NAT.png)

NAT被广泛使用，但是在业内也有很多反对的声音：第一，端口号应该用作区分进程，而不应该用作区分终端；第二，路由器应该最多支持到第三层网络层（读取端口号是第四层的工作）；第三，终端之间应该直接对话，而不能被中间人篡改地址；第四，应该使用IPv6来规避这些设计上的缺陷，而不是使用NAT这种临时解决方案。

另一个严重的问题是，NAT让P2P程序无法定位。回顾一下，P2P应用需要客户端之间互相建立连接，如果某个位于NAT后面的终端A，发送了局域网地址给一个外部的终端B，那么外部的终端B无法使用这个局域网地址与终端A建立连接。

#### UPnP

全称是『通用即插即用`Universal Plug and Play`』。主要内容是，子网内的终端可以向NAT请求`(公网IP,公网port)`到`(私网IP,私网port)`的映射关系（自己弄清楚自己的公网地址），这样就可以支持P2P了。

### 4.4.3 网络控制消息协议 ICMP

回顾一下网络层有三个成分：IP协议，路由协议（4.6章节说），和ICMP。

未完待续
