---
layout: post
title:  "Mysql的20条优化建议"
date:   2019-07-08
tags: MysqlDB
color: rgb(255,204,51)
---

> 看到这篇文章，觉得讲得不错，作者是php工程师，从Web应用的角度来考虑问题；
> 我自己从中学到很多东西，所以转载过来，翻译并加上一些自己的心得，与大家分享。

原文地址：[Top 20+ MySQL Best Practices](https://code.tutsplus.com/tutorials/top-20-mysql-best-practices--net-7855)

## 前言

> Database operations often tend to be the main bottleneck for most web applications today. 
> It's not only the DBA's (database administrators) that have to worry about these performance 
> issues. We as programmers need to do our part by structuring tables properly, writing optimized 
> queries and better code. In this article, I'll list some MySQL optimization techniques for programmers.

数据库操作往往是Web应用的性能瓶颈。不能仅由DBA来考虑性能问题，我们一般的开发者也要在自己的范围内，恰当地建表、优化查询。


## 1.充分利用缓存

`MySQL`服务器一般都开启了查询缓存(`query caching`)。
缓存是改善性能的最有效手段之一，而且完全是由数据库引擎`database engine`所控制的。
同一条查询语句`query`多次执行时，（后面的）结果会从缓存中提取。

> 数据库进程一般会自己维护缓存，你只管用（或者设置）就行了，不用担心实现细节。

但是其中有一些问题容易被忽视，比如在下面的情况中就无法使用查询缓存：

```php
// 缓存无效
$r = mysql_query("SELECT username FROM user WHERE signup_date >= CURDATE()");
 
// 应该这样写
$today = date("Y-m-d");
$r = mysql_query("SELECT username FROM user WHERE signup_date >= '$today'");

```

> 代码都是php写的，但是都很好理解吧。我没学过php，但是看起来有点像bash或者js的风格，还是可以理解的。

前面缓存无效，是因为`CURDATE()`没有确定的值，要由`Mysql`自己来执行，所以保存的查询记录是无效的；
而后面先把条件存为变量，这样的话提交给`Mysql`的查询语句就是一个确定的值，这样就可以进行缓存了。

## 2.使用`EXPLAIN`来分析你的查询语句

在你平常使用的查询语句**前面**加上`EXPLAIN`关键字，这样`MySQL`就会在返回的结果中告诉你，
这个查询`Query`用了哪个索引`Index`，如何对表进行扫描和排序的……之类的信息。

举一个平时译者在公司常用的查询语句作为例子：

```mysql
SELECT * FROM apmosdb.Trade where ap_code =  "省略" order by trade_datetime desc limit 300 ;
```

![EXPLAIN语句例图](/screenshot/2019-07-08-01-explain.png)

从上面的执行结果可以发现，如果我们在主键`Primary Key`上进行查询，只需要扫描1行，直接名中；
而如果在非索引的其他字段上查询，就要经历全表扫描。
对于我们公司70万行的数据量来说，性能差别不大；但是可以想象，对于互联网公司动辄千万上亿的数据量来说，这样的操作实在是太蠢了。

## 3.确定只有一行时，请用`Limit 1`

有时你想要获取`Fetch`一行，有时你只是想确认这行是否存在`Exist`；
如果你确定只有一行（或者固定的几行），请用`Limit`关键字。这样，当数据库检索到1行之后，就会停止检索了。

```php
// do I have any users from Alabama?
 
// 别这样做
$r = mysql_query("SELECT * FROM user WHERE state = 'Alabama'");
if (mysql_num_rows($r) > 0) {
    // ...
}
 
 
// 这样就好多了
$r = mysql_query("SELECT 1 FROM user WHERE state = 'Alabama' LIMIT 1");
if (mysql_num_rows($r) > 0) {
    // ...
}
```

## 4.在搜索字段上建立索引

就像前面说的，多建立一些索引吧，而不仅仅是在主键和唯一键`Unique Key`上才有索引。
如果你会经常在这个字段上搜索，那么大多数情况下你你都应该给他建立索引。
（当然，也别太随便就建立索引，因为它也是要占用空间的。）

![Index例图](/screenshot/2019-07-08-04-Index.jpg)

从上面原作者提供的截图我们可以看到，对于一个`Like 'a%'`搜索语句，建立索引后性能从(0.25 sec)上升到(0.06 sec)，提升明显。

但是要注意，有些情况下你不会从索引上获益（例如搜索一个单词`WHERE someCol LIKE '%apple%'`）。
你可以参考官方的[mysql fulltext search](https://dev.mysql.com/doc/refman/8.0/en/fulltext-search.html)，
或者构建你自己的索引解决方案。

## 5.使用`Join`的时候

如果应用程序`application`中含有大量的`Join`查询，你要注意

1. `Join`的列都建立了索引；这会影响`MySQL`内部的优化。
2. `Join`的列最好是相同的相同的字段类型`Type`

## 6.不要使用 `ORDER BY RAND()`

这种写法看起来很酷，很多新手会这样写。也许你只是想打乱序列`random rows`，但是在这种情况下`MySQL`不得不为每一行单独执行`RAND()`，
这是非常耗费CPU的；这导致了长时间的表锁，会导致更加严重的后果。

请用下面的写法：

```php
// 请不要这样写:
$r = mysql_query("SELECT username FROM user ORDER BY RAND() LIMIT 1");
 
 
// 这样会好很多: 
$r = mysql_query("SELECT count(*) FROM user");
$d = mysql_fetch_row($r);
$rand = mt_rand(0,$d[0] - 1); 
$r = mysql_query("SELECT username FROM user LIMIT $rand, 1");
```

## 7.明天更新