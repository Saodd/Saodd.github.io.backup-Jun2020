---
layout: post
title:  "Golang实现快速排序算法"
date:   2019-05-23
tags: Golang 算法与数据结构
color: rgb(102,204,204)
---

> 今天自己实现一下`快速排序`算法，发现它几乎是线性的时间复杂度，
对比`选择排序`的平方级时间复杂度，算是切身体会了一下**算法**的威力。

## 辅助代码

```golang
// 定义一个类
type sort_Quick struct {
}

// 检查数组是否有序
func (self sort_Quick) sort(li []int) {
	self._sort(li, 0, len(li)-1)
}

// 递归排序
func (self sort_Quick) _sort(li []int, lo, hi int) {
	if lo >= hi {
		return
	}
	mid := self.partition(li, lo, hi)
	self._sort(li, lo, mid-1)
	self._sort(li, mid+1, hi)
}

// 对比运行 ---------------------------------------------------------------
func Main0003() {
	data := mytools.Gen_ints_list(40000000)
	data2 := make([]int, len(data))
	starttime := time.Now()
	t := time.Microsecond
	// ---------------------------
	for i := range data{
		data2[i] = data[i]
	}
	fmt.Println("Checking input for Quick-sort:", is_Sorted(data2))
	starttime = time.Now()
	sort_Quick{}.sort(data2)
	t = time.Since(starttime)
	fmt.Printf("Quick-sort: %v,   used time: %v seconds.\n", is_Sorted(data2), t)
	// ---------------------------
	for i := range data{
		data2[i] = data[i]
	}
	fmt.Println("Checking input for Quick-sort-Book:", is_Sorted(data2))
	starttime = time.Now()
	sort_Quick_Book{}.sort(data2)
	t = time.Since(starttime)
	fmt.Printf("Quick-sort-Book: %v,   used time: %v seconds.\n", is_Sorted(data2), t)
```
道理很简单，但是核心是`partition(li, lo, hi)`这个函数。



## 我的实现

没有看书，自己琢磨了将近2个小时。
一开始我是很担心在递归中申请额外的变量会带来时间和空间的负担，
所以没有使用辅助变量。

```golang
func (self sort_Quick) partition(li []int, lo, hi int) int { 
	// mid和hi去循环
	mid := lo
	for mid<hi{
		for mid<hi{ // 寻找左边更大的元素
			if li[mid]>li[lo]{
				break
			}
			mid++
		}
		for mid<hi{ // 寻找右边更小的元素
			if li[hi]<li[lo]{
				break
			}
			hi--
		}
		if mid < hi{ // 没有相遇就交换二者
			li[mid], li[hi] = li[hi], li[mid]
		}else if li[mid]<li[lo]{ // 相遇了那就再检查一下相遇的位置，找到更小的
			li[mid], li[lo] = li[lo], li[mid]
			lo = mid
		}else { // 相遇了那就再检查一下相遇的位置，找到更小的
			li[mid-1], li[lo] = li[lo], li[mid-1]
			lo = mid -1
		}
	}
	return lo
}
```

## 书上的实现

我的算法书是红色那本*Robert Sedgewick*的《算法（第四版）》，
其实书上是用java实现的，我用golang表达一下。
最大的区别就是golang不支持i++在表达式内的使用。

```golang
func (self sort_Quick_Book) partition(li []int, lo, hi int) (mid int) {
	i,j := lo, hi+1 // 从结果看来，在递归函数中定义变量，并不会带来额外的内存开销
	v:= li[lo]
	for {
		for i++; li[i]<v;i++ {
			if i==hi{
				break
			}
		}
		for j--; v < li[j]; j--{
			if j==lo{
				break
			}
		}
		if i>=j {
			break
		}
		li[i] , li[j] = li[j] , li[i]
	}
	li[lo] , li[j] = li[j] , li[lo]
	return j
}
```

## 运行结果：

在2000万个int的条件下，我的实现vs书上的实现：

 - 1.94s/1.81s = 107%
 - 1.94s/1.81s = 107%
 - 1.95s/1.81s = 108%

我的更慢8% ……  


## 尝试改进

首先可以看到是我在内部循环中，对数组的访问多了一些，像这样的：
```golang
if li[mid]>li[lo]{
```
所以我设置一个辅助变量，并替换两个循环中的条件：
```golang
midv := li[lo]
...
li[mid]>midv
```
这种情况下再尝试一下：

 - 1.906/1.810 = 105.3%
 - 1.885/1.824 = 103.3%
 - 1.892/1.825 = 103.6%
 
在3%-4%的性能差距我觉得应该可以接受了吧，
多出来的部分应该是在边界检查的时候多少一两次操作导致的。
感觉也没有细节优化的余地了，除非把逻辑重写一遍。



## 在数量较小的情况下用插入排序

继承自书中的快速排序算法，加入插入排序的代码：
```golang
type sort_Quick_Book_Insert struct {
	sort_Quick_Book
	criterion int
}

func (self sort_Quick_Book_Insert) _sort(li []int, lo, hi int) {
	if lo >= hi {
		return
	}
	if hi-lo >= self.criterion {
		self.insert(li, lo, hi)
		return
	}
	mid := self.partition(li, lo, hi)
	self._sort(li, lo, mid-1)
	self._sort(li, mid+1, hi)
}
func (self sort_Quick_Book_Insert) insert(li []int, lo, hi int) {
	var temp, j, k int
	for i := lo + 1; i <= hi; i++ {
		temp = li[i]
		if temp < li[i-1] {
			// 更小的话就往前挪
			for j = lo; j < i; j++ {
				// j是这个更小的数字需要往前插入的位置
				if temp < li[j] {
					break
				}
			}
			// [....j.....i]把i移动到j
			for k = i; k > j; k-- {
				li[k] = li[k-1]
			}
			li[j] = temp
		}
	}
}
```
分别在最后5个数，10个数，20个数的情况下测试：
```golang
// ---------------------------
	for i := range data {
		data2[i] = data[i]
	}
	fmt.Println("Checking input for sort_Quick_Book_Insert(5):", is_Sorted(data2))
	starttime = time.Now()
	sort_Quick_Book_Insert{criterion: 5}.sort(data2)
	t = time.Since(starttime)
	fmt.Printf("sort_Quick_Book_Insert(5): %v,   used time: %v seconds.\n", is_Sorted(data2), t)

```
成绩（3次平均）：

 | 条件         | 成绩1           | 百分比   | 差距   |
 | ---         | ---             | ---     |---     |
 | 不使用插排   | 1.784369033     |  100%   |        |
 | 5个插排      | 1.7809862       | 99.81%  | -0.19%       |
 | 10个插排     | 1.776652067     | 99.57%  | -0.43%       |
 | 20个插排     | 1.777665267     | 99.62%  | -0.38%       |
 | 50个插排     | 1.768998333     | 99.14%  | -0.76%       |
 | 200个插排    | 1.7806776       | 99.79%  | -0.21%       |
 
可以看到，加入插入排序，可以让性能提升一点点……这一点点与代码复杂度相比，我觉得是得不偿失啊。



## 小结

**快速排序算法**已经将排序的时间复杂度压缩到了线性级别`T~=k*n`，相当于只是遍历一遍数组而已。
继续优化，也只是影响线性系数，而且考虑到带来更多的分支条件，性能未必会得到明显提升。
