---
layout: post
title:  "从邮箱中下载邮件（进阶版）"
date:   2019-09-10
tags: Python
color: rgb(255,204,51)
---

> 开发电子邮件解析工具时，有个很大的麻烦是下载问题。这里提供一个新的思路，将邮件下载下来，保存到本地的某个地方（Mongo）；然后从本地读出来，再进行解析。

## 使用ImapClient库

```python
def main():
    cst_tz = timezone(timedelta(hours=8))

    server = login()
    # 选择最近一天的所有邮件（注意，服务器可能是UTC时间，所以这个一天可能不准）
    select_msgid = server.search([u'SINCE', datetime.now() - timedelta(days=1, hours=0)])
    logger.debug("%d messages selected." % len(select_msgid))

    # 连接Mongo数据库
    with MongoClient(host="192.168.1.242") as mg:
        logger.debug("Mongo connected.")
        count = 0
        mgcl = mg.get_database("Email").get_collection("MO_raw")
        # 下载所有的邮件头
        for msgid, data in server.fetch(select_msgid, ["ENVELOPE"]).items():
            # 从邮件头中，解析出日期、主题、发件人，用于排除重复
            envelope = data[b'ENVELOPE']
            sender = envelope.sender[0]
            query = {"date": envelope.date.astimezone(cst_tz),
                     "subject": decode_subject(envelope.subject),
                     "sender": "%s@%s" % (
                     sender.mailbox.decode(errors='replace'), sender.host.decode(errors='replace'))}
            # 自定义筛选条件，并且到Mongo中查找是否有重复的记录
            if filter(query) and (mgcl.find_one(query) is None):
                # 新邮件，就下载邮件的主体数据（Body）
                body_raw = server.fetch([msgid], ["BODY.PEEK[]"])
                body = body_raw[msgid][b"BODY[]"]
                # 下载后存到Mongo中
                query["body"] = body
                mgcl.insert_one(query)
                logger.info(">>>subj: %(subject)s, >>>from: %(sender)s, >>>date: %(date)s. " % query)
                count += 1
        logger.info("Select %d mails, Inserted %d" % (len(select_msgid), count))
    server.logout()
```

## 解码问题

电子邮件有个最恶心的地方，就是它的编码格式。当你收到来自世界各地的邮件的时候，你会发现编码格式五花八门，让你无从下手。

光是解析一个标题就要了我的老命。我这里调用的是标准库中的`email.header.decode_header`，但是它的函数签名让我很难受，有时直接返回字符串，有时返回一个`List[tuple]`，十分麻烦。

```python
def decode_subject(subject) -> str:
    # 传入的是生数据，二进制的
    subject = email.header.decode_header(subject.decode(errors='replace'))
    # 标准库解析后，有可能直接就是字符串了
    if isinstance(subject, str):
        return subject
    # 不是字符串就打开列表
    subject = subject[0][0]
    encoding = subject[0][1]
    if isinstance(subject, bytes):
        if encoding:
            return subject.decode(encoding=encoding, errors='replace')
        return subject.decode(errors='replace')
    # 应该不会有意外情况吧……
    return subject
```

# TODO：接下来看一下解析邮件
