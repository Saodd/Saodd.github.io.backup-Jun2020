---
layout: post
title:  "[翻译] Why Generics?"
date:   2019-08-04
tags: Golang The-Go-Blog
color: rgb(102,204,204)
---

> 官方博客这篇文章引起了我的兴趣，是说有关于泛型的。文章内容感觉会比较重要，想着既然要看，就干脆翻译一下。

原文地址：[链接](https://blog.golang.org/why-generics)

## Why Generics?

Ian Lance Taylor
31 July 2019

## 介绍

这是`Gophercon 2019`一篇演讲的记录，可以找到视频。

这篇文章是关于：向Go中添加`泛型`意味着什么，以及为什么我认为我们应该这么做。

Go诞生于2009年11月10日，在不到24小时的时间内我们就看见了第一条关于`泛型`的评论（这条评论还提到了`异常`，我们在2010年添加了`panic`和`recover`来应对）。

在为其三年的Go语言调研中，`泛型的缺乏`在所有fix问题中位列前三名。

## 为什么要泛型？

引用 Jazayeri, et al 的话：`泛型编程`允许以通用的形式来表示`函数`和`数据结构`，并分析出`类型`。

一个简单的例子，假设我们反转`切片`中`元素`的顺序，这是很常见的：

```golang
func ReverseInts(s []int) {
    first := 0
    last := len(s)
    for first < last {
        s[first], s[last] = s[last], s[first]
        first++
        last--
    }
}
```

非常简单，但即使是这样一个简单的程序你也会想要写一些测试案例。事实上，我测试的时候发现了bug。
我敢肯定你们都发现了：

```folang
func ReverseInts(s []int) {
    first := 0
    last := len(s) - 1   // 译者注：这里
    for first < last {
        s[first], s[last] = s[last], s[first]
        first++
        last--
    }
}
```

接下来我们反转一个`字符串`：

```golang
func ReverseStrings(s []string) {
    first := 0
    last := len(s) - 1
    for first < last {
        s[first], s[last] = s[last], s[first]
        first++
        last--
    }
}
```

两个函数比较，它们真的极度相似，除了参数的类型不同以外。

很多Go的初学者都会被这个问题震惊：居然没有任何办法写一个简单的`Reverse`函数来处理任何类型对应的切片。

而绝大多数其他的语言允许你实现。

在动态类型语言，比如`Python`或者`JS`你可以非常简单的写，根本不用考虑类型问题。
而Go不行，它是静态类型的，而且要求你写下准确的`切片`类型和`元素`类型。

其他静态类型语言，比如`C++`, `Java`等，都支持泛型来解决你的这个问题。

## 现在的Go泛型

那么现在的人们如何在Go中实现这样的功能？

你可以用`接口`，并在你想要传入的`切片`类型上定义一个`方法`。
这也是标准库中`sort.Sort`的实现原理。

换句话说，`接口`就是Go中的`泛型编程`。
`接口`允许我们捕捉不同`类型`之间相同的特性(They let us capture the common aspects of different types)并将它们表达为`接口方法`。
我们可以根据`接口`来编程，然后这个函数可以在任何实现了这些`接口方法`的类型上运行。

但这不是我们想要的。使用`接口`你不得不自己写`接口方法`。就为了一个简单的功能，你不得不给一个已有的`类型`定义一批`接口方法`，这会是非常烦人的。并且你给每个`类型`写的`接口方法`都是极度相似的。
所以`接口`并不是真正的`泛型`。

另一种可以不用自己为`类型`写`接口方法`的方法，将会是让语言本身给某些`类型`定义`接口方法`。
现在Go并不支持，举个例子，语言可以定义每种`切片类型`都有一个`Index`方法可以返回一个`元素`。但是为了实现它，那返回值`类型`就必须是一个`空接口`，那么我们`静态类型语言`所带来的好处就一无所有了。再讲细节一些，我们将没有办法写一个允许接收两个相同`类型`的不同`切片`对象的`泛型`函数，或者一个允许接收某种元素类型的map并返回相应元素类型的slice的`泛型`函数。Go是`静态类型语言`是因为这使得编写大型程序更容易，我们不希望损失了`静态类型语言`的好处来获得`泛型`的好处。

还有一种办法是用`反射`包，但它写起来很烦人，而且效率很慢，所以很少人用它。而这种方法依然要求准确的`类型断言`并且没有`静态类型检查`了。

再再再有一种办法，就是你写一个`代码生成器`来给每个`类型`生成相应的方法。目前就有几种`代码生成器`实现了类似的功能。但是，它增加了额外的步骤；并且使`构建`变得复杂，因为必须`编译`所有不同的副本；而且每次修复bug都要重新`编译`所有的`实例`，其中一些`实例`可能完全位于不同的项目中。

所有的方法都非常麻烦，所以我认为人们必须每次现写一个函数来为特定的`类型`实现这样简单的功能。然后接着又是`测试案例`，来确保不会不小心犯下低级错误。

> 译者注：的确，我现在就是这样做的，每一个简单的功能都要附带测试，非常麻烦。

## 泛型能给Go带来什么

首先我们最想要`泛型`带给我们的是，允许我们编写类似`Reverse`这样通用的函数而不用考虑具体的`类型`。我们想要分解出元素类型，然后我们就只需要写一次这个函数，写一次测试，然后放在GoPATH，就可以随心所欲的用它了。

更理想的是，既然处在开源的世界中，只要某人写了一次`Reverse`函数，那么全世界的人都可以用了。

其实`泛型`意味着很多很多很多好处，但此时我只说这些。特别地，我不是指c++那种`模板`(templates)，它支持的功能比我在这里所写的要多很多。

除了`Reverse`，还有很多例子可以实现，比如：

- Max(), Min()  in slice
- Average(), StandardDeviation()   of slice
- union(), intersection()   of map
- `图`中的最短路径

还有一些例子，是Go特有的（利用其强大的`并发`特性）:

- 带有等待时间限制地从`信道`中读取
- 将两个`信道`合并为一个
- `并发`调用一批`函数`，并将结果以`切片`形式返回
- 使用`上下文`(Context)来`并发`调用一批`函数`，只需要第一个完成的返回结果，同时取消其他的Go程

这些功能已经有很多实现了，在Go中并不难。但是如果能够`复用`一个高效的并且经过调试的`实现`，将会是很棒的。

除了函数，还有数据结构。

Go有两种类型通用的数据结构——Map和slice。它们可以持有任何类型的数据，还能带有`静态类型检查`，并且所有数值都是原样保存，而不是用了`接口`。

除了它们以外，还有：

- Sets  集合
- Self-balancing trees   平衡树，能高效、有序地插入和遍历
- Multimaps   多重字典，允许多个对象作为键
- Concurrent hash maps   同步哈希表，允许并发插入和查询，而不需要锁

如果我们能实现`泛型`，我们就可以定义像上面这些的`数据结构`。而且我们可以引入更多的`算法`。

## 收益和成本

但是`泛型`并不是天上掉下来的，每一个语言上的改进都是有代价的。毫无疑问引入`泛型`会让语言变得更加复杂。和其他特性一样，我们必须要讨论如何最大化利益并且最小化代价。

在Go中，我们的目标是通过可以自由组合的独立的、正交的语言特性来降低复杂性。我们让独立的特性保持简单，并允许它们自由组合，以此降低复杂性。对于`泛型`，我们也想要这样做。

我必须强调几个大纲：

1. 尽可能少的新概念(concepts)

    即最少的新语法、新关键字和其他名称。

2. 复杂度应该由泛型开发者承担，而不是使用者

    我们不希望用户担为`泛型`感到焦虑。这意味着调用`泛型函数`必须通过自然的方式，意味着错误处理也要易于理解和修复。

    > 译者注：这里说的开发者，并不是说语言层面的开发者，而是指某个泛型类库的开发者。

3. 开发者和用户互不干涉

    我们希望`泛型`功能的开发者与用户二者关心的东西能够很容易地分开，这样他们可以互相独立地开发。他们不必担心另一个函数在做什么，就像不同包中的正常函数的编写者和调用者不必担心一样。这听起来很奇怪，但是其他任何语言的`泛型`功能都没有做到这一点。

4. 减少编译实践，加速执行效率

    我们想要保持目前Go语言的快速编译与高效执行的特性。`泛型`往往会让我们在编译效率与执行效率之间做权衡，但我们希望鱼与熊掌兼得。

5. 保持语言的清晰和简单

    最重要的是，现在的Go是一门非常简洁的语言。Go程序总是非常清晰并且容易理解。我们在探索这个领域的漫长过程中，一直试图理解如何添加泛型，同时保持这种清晰和简单。我们需要找到一种机制来尽可能地适配现在地语言，而不是把它变成一个新的玩意。

以上几点内容适用于任何一个Go的`泛型`实现。最最重要的一点就是，虽然`泛型`可以给语言带来巨大的好处，但是**如果它使得Go不再像Go了，那就没有任何意义了。**

## 设计草稿

未完待续……