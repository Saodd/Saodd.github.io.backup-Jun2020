---
layout: post
title:  "算法-快速排序算法"
date:   2019-07-23
tags: 算法与数据结构
color: rgb(102,204,204)
---

> （原文写于5-23，重写）`快速排序`算法，平均情况下时间复杂度为`O(nlogn)`，
是非常优秀了。据我所知，快排也是多数情况下的默认算法。

![All Algo](/screenshot/2019-07-23-SortAlgo-Complexity.png)

## Golang实现

```golang
func QuickSortInt(li []int) {
    quickSortInt(li, 0, len(li)-1)
}

func quickSortInt(li []int, lo, hi int) {
    if hi-lo < 2 {
        quickSortIntSelectSort(li, lo, hi)
        return
    }
    mid := quickSortIntPartition(li, lo, hi)
    //fmt.Println(mid, lo, hi)
    quickSortInt(li, lo, mid-1)
    quickSortInt(li, mid+1, hi)
}

func quickSortIntPartition(li []int, lo, hi int) (mid int) {
    l, r := lo, hi
    midValue := li[lo]
    for l<r{
        for l<=hi{ // 找大的
            if li[l]>midValue{
                break
            }
            l++
        }
        for r>=lo{
            if li[r]<=midValue{
                break
            }
            r--
        }
        if l<r{
            li[l], li[r] = li[r], li[l]
        }else {
            break
        }
    }
    li[lo], li[r] = li[r], li[lo]
    return r
}

func quickSortIntSelectSort(li []int, lo, hi int) {
    var min int
    for ; lo<hi; lo++{
        min = lo
        for i:=lo+1; i<=hi; i++{
            if li[i]<li[min]{
                min = i
            }
        }
        if lo != min{
            li[lo], li[min] = li[min], li[lo]
        }
    }
}
```

## Python实现

```python
def quick_sort(arr: list) -> list:
    if len(arr) < 2:
        return arr
    mid = _quick_part(arr)
    arr[:mid] = quick_sort(arr[:mid])
    arr[mid + 1:] = quick_sort(arr[mid + 1:])
    return arr

def _quick_part(arr: list) -> int:
    midValue = arr[0]
    high = len(arr) - 1
    left, right = 0, high
    while left < right:
        while left <= high:
            if arr[left] > midValue:
                break
            left += 1
        while right >= 0:
            if arr[right] <= midValue:
                break
            right -= 1
        if left<right:
            arr[left], arr[right] = arr[right], arr[left]
        else:
            break
    arr[0], arr[right] = arr[right], arr[0]
    return right
```

## 性能对比

```golang
func TestQuickSortInt_time(t *testing.T){
    start := time.Now()
    QuickSortInt(tools.Gen_ints_list(100000))
    d := time.Since(start)
    fmt.Println(d)
}

// 32.9995ms
```

```python
glb = {"quick_sort":quick_sort, "_quick_part":_quick_part, "random":random}
smd = "quick_sort([random.random() for i in range(100000)])"
d = timeit.timeit(cmd, number=1, globals=glb)
print(d)

# 0.29713020000000007
```

`32ms` vs `0.29s`，大约10倍。